setwd("C:/Users/abhik/Desktop/Work Folder/R Projects/Digit Recognition")
train_data <- read.csv("mnist_train.csv", stringsAsFactors = F)
test_data <- read.csv("mnist_test.csv", stringsAsFactors = F)
# The first column seems to be the label of the datasets
names(train_data)[1] <- "DIGIT"
names(test_data)[1] <- "DIGIT"
colnames(train_data)
colnames(test_data)
common_cols <- intersect(colnames(train_data), colnames(test_data))
common_cols
library(dplyr)
train_data <- select(train_data, common_cols)
test_data <- select(test_data, common_cols)
# Changing output variable "DIGIT" to factor type
train_data$DIGIT <- as.factor(train_data$DIGIT)
test_data$DIGIT <- as.factor(test_data$DIGIT)
# Checking missing value
sapply(train_data, function(x) sum(is.na(x))) # No missing values
sapply(test_data, function(x) sum(is.na(x))) # No missing values
set.seed(100)
train_subset.indices = sample(1:nrow(train_data), 0.15*nrow(train_data))
train = train_data[train_subset.indices, ]
max(train[ ,2:ncol(train)]) # max pixel value is 255, lets use this to scale data
train[ , 2:ncol(train)] <- train[ , 2:ncol(train)]/255
#test <- cbind(label = test_data[ ,1], test_data[ , 2:ncol(test_data)]/255)
test <- test_data[ , 2:ncol(test_data)]/255
Model_linear <- ksvm(DIGIT~ ., data = train, scaled = FALSE, kernel = "vanilladot")
library(kernlab)
library(readr)
library(caret)
library(caTools)
library(e1071)
library(dplyr)
Model_linear <- ksvm(DIGIT~ ., data = train, scaled = FALSE, kernel = "vanilladot")
print(Model_linear)
Eval_linear<- predict(Model_linear, test)
#confusion matrix - Linear Kernel
confusionMatrix(Eval_linear,test_data$DIGIT)
#Using RBF Kernel
Model_RBF <- ksvm(letter~ ., data = train, scale = FALSE, kernel = "rbfdot")
#Using RBF Kernel
Model_RBF <- ksvm(DIGIT~ ., data = train, scale = FALSE, kernel = "rbfdot")
#Using RBF Kernel
Model_RBF <- ksvm(DIGIT~ ., data = train, scaled = FALSE, kernel = "rbfdot")
train_data <- read.csv("mnist_train.csv", stringsAsFactors = F)
test_data <- read.csv("mnist_test.csv", stringsAsFactors = F)
names(train_data)[1] <- "DIGIT"
names(test_data)[1] <- "DIGIT"
colnames(train_data)
colnames(test_data)
# take subset of common columns
common_cols <- intersect(colnames(train_data), colnames(test_data))
train_data <- select(train_data, common_cols)
test_data <- select(test_data, common_cols)
# Changing output variable "DIGIT" to factor type
train_data$DIGIT <- as.factor(train_data$DIGIT)
test_data$DIGIT <- as.factor(test_data$DIGIT)
set.seed(100)
train_subset.indices = sample(1:nrow(train_data), 0.15*nrow(train_data))
train = train_data[train_subset.indices, ]
max(train[ ,2:ncol(train)]) # max pixel value is 255, lets use this to scale data
train[ , 2:ncol(train)] <- train[ , 2:ncol(train)]/255
test[ , 2:ncol(test)] <- test_data[ , 2:ncol(test_data)]/255
max(train[ ,2:ncol(train)]) # max pixel value is 255, lets use this to scale data
train[ , 2:ncol(train)] <- train[ , 2:ncol(train)]/255
test[ , 2:ncol(test)] <- test_data[ , 2:ncol(test_data)]/255
train[ , 2:ncol(train)] <- train[ , 2:ncol(train)]/255
test <- cbind(test_data[,1],test_data[ , 2:ncol(test_data)]/255)
Model_linear <- ksvm(DIGIT~ ., data = train, scaled = FALSE, kernel = "vanilladot")
print(Model_linear)
Eval_linear<- predict(Model_linear, test)
#confusion matrix - Linear Kernel
confusionMatrix(Eval_linear,test_data$DIGIT)
#Using RBF Kernel
Model_RBF <- ksvm(DIGIT~ ., data = train, scaled = FALSE, kernel = "rbfdot")
Eval_RBF<- predict(Model_RBF,test)
#confusion matrix - RBF Kernel
confusionMatrix(Eval_RBF,test_data$DIGIT)
train_data <- read.csv("mnist_train.csv", stringsAsFactors = F)
test_data <- read.csv("mnist_test.csv", stringsAsFactors = F)
names(train_data)[1] <- "DIGIT"
names(test_data)[1] <- "DIGIT"
colnames(train_data)
colnames(test_data)
# take subset of common columns
common_cols <- intersect(colnames(train_data), colnames(test_data))
train_data <- select(train_data, common_cols)
test_data <- select(test_data, common_cols)
# Changing output variable "DIGIT" to factor type
train_data$DIGIT <- as.factor(train_data$DIGIT)
test_data$DIGIT <- as.factor(test_data$DIGIT)
# Sampling the data to make the computation faster
set.seed(100)
train_subset.indices = sample(1:nrow(train_data), 0.15*nrow(train_data))
train = train_data[train_subset.indices, ]
set.seed(100)
train_subset.indices = sample(1:nrow(train_data), 0.15*nrow(train_data))
train = train_data[train_subset.indices, ]
test <- test_data[train_subset.indices, ]
train_subset.indices = sample(1:nrow(train_data), 0.15*nrow(train_data))
set.seed(100)
train_subset.indices = sample(1:nrow(train_data), 0.15*nrow(train_data))
train = train_data[train_subset.indices, ]
test <- test_data[train_subset.indices, ]
set.seed(100)
train_subset.indices = sample(1:nrow(train_data), 0.15*nrow(train_data))
train = train_data[train_subset.indices, ]
test_subset.indices = sample(1:nrow(test_data), 0.15*nrow(test_data))
test <- test_data[test_subset.indices, ]
Model_linear <- ksvm(DIGIT~ ., data = train, scaled = FALSE, kernel = "vanilladot")
print(Model_linear)
Eval_linear<- predict(Model_linear, test)
#confusion matrix - Linear Kernel
confusionMatrix(Eval_linear,test_data$DIGIT)
#confusion matrix - Linear Kernel
confusionMatrix(Eval_linear,test$DIGIT)
#Using RBF Kernel
Model_RBF <- ksvm(DIGIT~ ., data = train, scaled = FALSE, kernel = "rbfdot")
Eval_RBF<- predict(Model_RBF,test)
#confusion matrix - RBF Kernel
confusionMatrix(Eval_RBF,test$DIGIT)
trainControl <- trainControl(method="cv", number=5)
# Metric <- "Accuracy" implies our Evaluation metric is Accuracy.
metric <- "Accuracy"
#Expand.grid functions takes set of hyperparameters, that we shall pass to our model.
set.seed(7)
grid <- expand.grid(.sigma=c(0.025, 0.05), .C=c(0.1,0.5,1,2) )
#train function takes Target ~ Prediction, Data, Method = Algorithm
#Metric = Type of metric, tuneGrid = Grid of Parameters,
# trcontrol = Our traincontrol method.
fit.svm <- train(DIGIT~., data=train, method="svmRadial", metric=metric,
tuneGrid=grid, trControl=trainControl)
trainControl <- trainControl(method="cv", number=5)
metric <- "Accuracy"
set.seed(7)
grid <- expand.grid(.sigma=c(0.025, 0.05), .C=c(0.1,0.5,1,2) )
install.packages("doParallel")
library(doParallel)
cl <- makePSOCKcluster(5)
registerDoParallel(cl)
fit.svm <- train(DIGIT~., data=train, method="svmRadial", metric=metric,
tuneGrid=grid, trControl=trainControl)
